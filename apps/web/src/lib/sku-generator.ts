/**
 * Auto-generate SKU based on product attributes
 * Pattern: {TenantKey}-{ProductType}-{DeliveryMethod}-{AccessControl}-{Random}
 * 
 * Examples:
 * - AB3K-PHYS-SHIP-PUBL-A7K9
 * - XY9M-DIGI-DWNL-PERS-B3M2
 * - QR5T-HYBR-LINK-SUBS-C5N8
 */

export interface SKUGenerationParams {
  tenantKey?: string; // 4-character tenant identifier
  productType: 'physical' | 'digital' | 'hybrid';
  deliveryMethod?: 'direct_download' | 'external_link' | 'email_delivery' | 'license_key' | 'access_grant' | 'shipping' | 'pickup' | 'delivery';
  accessControl?: 'personal' | 'commercial' | 'enterprise' | 'educational' | 'public' | 'subscription';
}

const PRODUCT_TYPE_CODES: Record<string, string> = {
  physical: 'PHYS',
  digital: 'DIGI',
  hybrid: 'HYBR',
};

const DELIVERY_METHOD_CODES: Record<string, string> = {
  direct_download: 'DWNL',
  external_link: 'LINK',
  email_delivery: 'MAIL',
  shipping: 'SHIP',
  pickup: 'PICK',
  delivery: 'DELV',
};

const ACCESS_CONTROL_CODES: Record<string, string> = {
  personal: 'PERS',
  commercial: 'COMM',
  enterprise: 'ENTR',
  public: 'PUBL',
  subscription: 'SUBS',
};

/**
 * Generate a random alphanumeric suffix (4 characters)
 */
function generateRandomSuffix(): string {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Removed ambiguous chars (0, O, 1, I)
  let result = '';
  for (let i = 0; i < 4; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}

/**
 * Generate a tenant key from tenant ID
 * Converts tenant ID to a 4-character alphanumeric key
 */
export function generateTenantKey(tenantId: string): string {
  if (!tenantId) return 'UNKN';
  
  // Use a simple hash to create consistent 4-char key from tenant ID
  let hash = 0;
  for (let i = 0; i < tenantId.length; i++) {
    hash = ((hash << 5) - hash) + tenantId.charCodeAt(i);
    hash = hash & hash; // Convert to 32-bit integer
  }
  
  // Convert hash to 4-character alphanumeric key
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let tempHash = Math.abs(hash);
  let key = '';
  for (let i = 0; i < 4; i++) {
    key += chars[tempHash % chars.length];
    tempHash = Math.floor(tempHash / chars.length);
  }
  
  return key;
}

/**
 * Generate SKU based on product attributes
 */
export function generateSKU(params: SKUGenerationParams): string {
  const parts: string[] = [];

  // Tenant key (optional but recommended)
  if (params.tenantKey) {
    parts.push(params.tenantKey.toUpperCase().substring(0, 4).padEnd(4, 'X'));
  }

  // Product type (required)
  parts.push(PRODUCT_TYPE_CODES[params.productType] || 'PROD');

  // Delivery method (optional, defaults based on product type)
  let deliveryMethod = params.deliveryMethod;
  if (!deliveryMethod) {
    // Auto-detect delivery method based on product type
    if (params.productType === 'digital') {
      deliveryMethod = 'direct_download';
    } else if (params.productType === 'physical') {
      deliveryMethod = 'shipping';
    } else {
      deliveryMethod = 'direct_download'; // hybrid defaults to digital delivery
    }
  }
  parts.push(DELIVERY_METHOD_CODES[deliveryMethod] || 'UNKN');

  // Access control (optional, defaults to public for physical, personal for digital)
  let accessControl = params.accessControl;
  if (!accessControl) {
    accessControl = params.productType === 'physical' ? 'public' : 'personal';
  }
  parts.push(ACCESS_CONTROL_CODES[accessControl] || 'PUBL');

  // Random suffix for uniqueness
  parts.push(generateRandomSuffix());

  return parts.join('-');
}

/**
 * Validate if a string looks like an auto-generated SKU
 */
export function isAutoGeneratedSKU(sku: string): boolean {
  // Pattern: XXXX-XXXX-XXXX-XXXX (4 parts, each 4 chars)
  const pattern = /^[A-Z]{4}-[A-Z]{4}-[A-Z]{4}-[A-Z0-9]{4}$/;
  return pattern.test(sku);
}

/**
 * Parse an auto-generated SKU back into its components
 */
export function parseSKU(sku: string): Partial<SKUGenerationParams> | null {
  if (!isAutoGeneratedSKU(sku)) return null;

  const parts = sku.split('-');
  const [productTypeCode, deliveryCode, accessCode] = parts;

  // Reverse lookup
  const productType = Object.entries(PRODUCT_TYPE_CODES).find(([_, code]) => code === productTypeCode)?.[0] as any;
  const deliveryMethod = Object.entries(DELIVERY_METHOD_CODES).find(([_, code]) => code === deliveryCode)?.[0] as any;
  const accessControl = Object.entries(ACCESS_CONTROL_CODES).find(([_, code]) => code === accessCode)?.[0] as any;

  return {
    productType,
    deliveryMethod,
    accessControl,
  };
}
